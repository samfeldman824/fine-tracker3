# TypeScript Type Organization Guide

## Overview

This guide outlines the best practices for organizing TypeScript types in the Fine Tracker project.

## Type Organization Strategy

### 1. Centralized Type Structure

```
src/types/
├── models.ts          # Domain models (User, Fine, etc.)
├── supabase.ts        # Generated Supabase types (auto-generated)
├── api.ts            # API request/response types
├── common.ts         # Shared utility types
└── ui.ts             # UI component prop types (future)
```

### 2. Type Categories

#### **Domain Models** (`models.ts`)
- Database entity types
- Business logic types
- Extended types for UI components
- Form data types

```typescript
// Example from models.ts
export type User = Tables<"users">;
export type UserSelect = Pick<User, "id" | "username" | "name">;
export type AddFineFormData = {
  offender_id: string;
  description: string;
  amount: number;
  date: string;
};
```

#### **API Types** (`api.ts`)
- Database query result types
- API function return types
- Supabase response wrappers

```typescript
// Example from api.ts
export type FineWithUsersQuery = {
  id: string;
  date: string;
  description: string;
  amount: number;
  replies: number;
  offender: { name: string } | { name: string }[] | null;
  proposer: { name: string } | { name: string }[] | null;
};
```

#### **Common Types** (`common.ts`)
- Utility types used across the application
- Generic wrappers
- Shared interfaces

```typescript
// Example from common.ts
export type ApiResponse<T> = {
  data: T | null;
  error: string | null;
  success: boolean;
};

export type LoadingState = "idle" | "loading" | "success" | "error";
```

#### **Generated Types** (`supabase.ts`)
- Auto-generated by Supabase CLI
- **DO NOT MODIFY** - regenerated on schema changes
- Base types for database operations

## When to Use Each Approach

### ✅ Centralize These Types:
- **Database models** (User, Fine, etc.)
- **API types** (request/response shapes)
- **Shared business logic** types
- **Cross-component** types
- **Form data** types
- **Utility types** used in multiple places

### ✅ Keep Local These Types:
- **Component-specific** prop interfaces
- **Temporary/local** utility types
- **Single-file** only types
- **Inline** simple types

## Best Practices

### 1. Import Organization
```typescript
// Group imports by type
import { User, Fine, UserSelect } from "@/types/models";
import { FineWithUsersQuery } from "@/types/api";
import { LoadingState, ApiResponse } from "@/types/common";
```

### 2. Type Naming Conventions
- **Entities**: `User`, `Fine`, `Credit`
- **UI Types**: `UserSelect`, `FineTableRow`
- **API Types**: `FineWithUsersQuery`, `GetFinesResult`
- **Form Types**: `AddFineFormData`, `EditUserFormData`
- **Utility Types**: `ApiResponse<T>`, `LoadingState`

### 3. Type Composition
```typescript
// Use Pick, Omit, Partial for derived types
export type UserSelect = Pick<User, "id" | "username" | "name">;
export type FineUpdate = Partial<Fine>;
export type FineWithoutId = Omit<Fine, "id">;
```

### 4. Generic Types
```typescript
// Use generics for reusable patterns
export type ApiResponse<T> = {
  data: T | null;
  error: string | null;
  success: boolean;
};
```

## Migration Checklist

- [x] Created centralized type files
- [x] Moved duplicate `User` types to `models.ts`
- [x] Created `UserSelect` type for UI components
- [x] Moved API types to `api.ts`
- [x] Created common utility types
- [x] Updated component imports

## Future Improvements

1. **Add UI types file** for component prop interfaces
2. **Create validation schemas** (Zod) alongside types
3. **Add type guards** for runtime type checking
4. **Document complex types** with JSDoc comments
5. **Add type tests** for critical type definitions

## Benefits of This Approach

1. **Single Source of Truth**: Types are defined once and reused
2. **Better IntelliSense**: Centralized types provide better IDE support
3. **Easier Refactoring**: Changes in one place propagate everywhere
4. **Reduced Duplication**: No more duplicate type definitions
5. **Better Maintainability**: Clear organization makes types easier to find and update
6. **Type Safety**: Consistent types across the application
